search algorithm ideas:
    convert search from infix to postfix
    for each term, check if that term evaluates to true
    replace the term in the expression with T if true or F if false
    then evaluate the expression


keywords:
    && - AND operator
    || - OR operator
    ^^ - XOR operator
    !! - NOT 
        negates the term after the !!
        e.g. if "potato" is true, then "!!potato" (or "!! potato") is false

terms:
    (term)
        evaluates to whatever is within the brackets
        this is used for precedence
    "x" - literal
        all keywords and terms and commands are just interpreted as strings
    r"x" - regex string
        evaluates whatever is in quotes as a regex string
    [term1, term2, term3, ... termN] - term list
        will run the check with each term in the list
        will only evaluate to true if it evaluates to true for each entry in the list seperately
    /M(term, type)
        short for match
        matches term to specific parts of the file's entry, like quotes or filename
        include characters in type based on what to match:
            t is tags, q is quotes, n is notes, f is filename, p is file path, c is text file contents
        e.g. /MATCH(blah, nft) will evaluate to true if "blah" is in notes, the filename or a tag
    /CM(termlist, match1, match2, match3...)
        short for "complex match" because boy oh boy is it complex
        converts the termlist and all matches to a list of booleans
        if the list based on termlist is the same as any of the lists based on matches, evaluates to true
        e.g. for match string tfftf:
            becomes [T, F, F, T, F]
            and will evaluate to true if termlist[0] && !!termlist[1] && !!termlist[2] && termlist[3] && !!termlist[4]
        e.g. /CMATCH([a, b, c], ttf, tff, ftf)
        returns true if:
            a and b are true but c isnt, OR
            a is true but c and b arent, OR
            b is true but a and c arent
    /NUM(num1, op, num2 [op2, num3, [op3, num4...]])
        compares the of num1 to num2, using boolean comparison op.
        if there are any more parameters it compares num1 to numN using op(N-1)
        you can use any boolean comparison (<, >, <=, >=, ==, !=)
        has its own variables and functions:
            LENGTH : length of the file in seconds if its audio/video
                if its not audio and contains this then it evaluates to false automatically
            YEAR, MONTH, DAY: values from the path
            CHARCOUNT: amount of characters if its a text file
            WORDCOUNT: amount of words if its a text file
            LINECOUNT: amount of lines if its a text file
                if its not text and contains these last 3 then it evaluates to false automatically
            DISTW(term1, term2): distance between term1 and term2 in words
            DISTC(term1, term2): distance between term1 and term2 characters
        e.g. /NUM(LENGTH, >, 16, <, DAY)
            evaluates to true if the file's length is less than 16 but more than the file's day
    /EXT(ext1, ext2, ext3...)
        checks if the file extension is any extension within the brackets

//////////////
// EXAMPLES //
//////////////

e.g.
mp3 file 33 seconds long
quote is: "izzy's 17th party was alright but i wish i hadn't played videogames and called the mailman a poopoo head"
tags: izzy, party, vidya
notes: "oh god how drunk was i"

query is: party && !! 18th && !! (tyler || connor)
in postfix: "party" "!! 18th" && "!! (tyler || connor)" &&
    deal with brackets: tyler || connor
    in postfix: "tyler" "connor" ||
        tyler is false and connor is false
    FALSE FALSE ||
        evaluates to false
"party" "!! 18th" && "!! FALSE" &&
    "party" evaluates to true
    "18th" is false, so "!! 18th" is true
    "!! FALSE" is true
TRUE TRUE && TRUE &&
    which is true
therefore file is a match

query is: /M(alright, qc) || /CM([videogames, banana, someguy], ftf, fft, tff)
in postix: /M(alright, qc) /CM([videogames, banana, someguy], ftf, fft, tff) ||
    deal with the /M
        alright is in quotes, and we're checking quotes due to q, so its true
TRUE /CM([videogames, banana, someguy], ftf, fft, tff) || 
    deal with the /CM
        [videogames, banana, someguy] is [T, F, F]
        the 3 possible boolean lists to match are [F, T, F], [F, F, T], [T, F, F]
        it matches the last one, therefore its true
TRUE TRUE ||
    which is true
therefore file is a match

query is: /CM(["izzy", r"\d\dth", /MATCH(drunk, tc), /NUM(LENGTH, >, 12, <, 40)], tfft, fttf)
postfix is the same as infix
    deal with the /CM
        convert term list to boolean list
            "izzy" is true
            \d\dth is a regex string and matches 17th, so it's true
            drunk is in notes, but not tags and not file contents, so its false
            since the file length (33) > 12 and < 40 its true
        the boolean list is [T, T, F, T]
        compare to other boolean lists:
            which are [T, F, F, T] and [F, T, T, F]
        none of which mach the term boolean list
    this is false
the result is just FALSE
therefore not a match
        
            
